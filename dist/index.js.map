{"version":3,"file":"index.js","sources":["../src/helpers.js","../src/enums.js","../src/symbols.js","../src/errors.js","../src/DescriptorType.js","../src/Descriptor.js","../src/Blueprint.js","../src/Extractor.js","../src/index.js"],"sourcesContent":["/**\n * Checks whether a value is empty (null, undefined, '', [], {}).\n *\n * Adapted from https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_isempty\n */\nexport const empty = function (value) {\n    if (['number', 'boolean'].includes(typeof value)) return false;\n\n    return [Object, Array].includes((value || {}).constructor) && !Object.entries(value || {}).length;\n};\n\n/**\n * Javascript lacks assertions. But it's simple to roll our own.\n *\n * Shamelessly adapted from https://stackoverflow.com/a/15313435\n *\n * @param condition\n * @param message\n */\nexport const assert = function (condition, message = '') {\n    if (!condition) {\n        message = ['Assertion failed', message].join(': ');\n        if (typeof Error !== 'undefined') {\n            throw new Error(message);\n        }\n        throw message; // Fallback\n    }\n};\n\nexport const Enum = class {\n    constructor(elements = {}) {\n        this.elements = elements;\n\n        // proxy enables accessing enum values on the parent object via the elements-array\n        // e.g. SomeEnum.someValue will resolve to SomeEnum.elements.someValue\n        return new Proxy(this, {\n            get(target, prop, receiver) {\n                if (!Reflect.has(target, prop)) {\n                    return target.elements[prop];\n                }\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n    }\n\n    has(element) {\n        return this.values.includes(element);\n    }\n\n    get values() {\n        return Object.values(this.elements);\n    }\n};\n\n// https://github.com/sindresorhus/is-plain-obj/blob/main/index.js\nexport const isPlainObject = function (value) {\n    if (Object.prototype.toString.call(value) !== '[object Object]') {\n        return false;\n    }\n\n    const prototype = Object.getPrototypeOf(value);\n    return prototype === null || prototype === Object.prototype;\n};\n","import { Enum } from './internal';\n\nexport const Modifier = new Enum({\n    MAYBE: 'maybe',\n    OPTIONAL: 'optional'\n});\n","export const MissingKeyOrValue = Symbol('missing key or value');\n","export const MissingKeyError = class extends Error {\n    constructor(key, raw) {\n        super(`The key '${key}' is missing from the object to be converted: ${JSON.stringify(raw, null, 2)}.`);\n        this.name = 'MissingKeyError';\n    }\n};\n\nexport const IllegalModifierError = class extends Error {\n    constructor(modifier = null) {\n        super(`'${modifier}' is not a valid modifier.`);\n        this.name = 'IllegalModifierError';\n    }\n};\n\nexport const BlueprintSpecificationError = class extends Error {\n    constructor(type) {\n        super(`Blueprint specification contains illegal element of type ${type}.`);\n        this.name = 'BlueprintSpecificationError';\n    }\n};\n\nexport const ValidationError = class extends Error {\n    constructor(value, key = null) {\n        const message = ['Property', key ? ' with key ' + key : '', ' of type ' + typeof value, ' is invalid.'].join(\n            ''\n        );\n\n        super(message);\n        this.name = 'ValidationError';\n    }\n};\n","import { assert, ValidationError } from './internal';\n\nexport class DescriptorType {\n    _validate;\n    _convert;\n    _makeNullValue;\n    _name;\n\n    constructor(callbacks, name = '') {\n        ['validate', 'convert', 'makeNull'].forEach((callbackName) => {\n            assert(\n                callbacks.hasOwnProperty(callbackName),\n                `Cannot instantiate DescriptorType: missing callback '${callbackName}'.`\n            );\n            assert(\n                typeof callbacks[callbackName] === 'function',\n                `Cannot instantiate DescriptorType: '${callbackName}' should be a function.`\n            );\n        });\n\n        this._validate = callbacks.validate;\n        this._convert = callbacks.convert;\n        this._makeNullValue = callbacks.makeNull;\n        this._name = name;\n\n        this._checkArities();\n    }\n\n    _checkArities() {\n        assert(this._validate.length === 1);\n        assert(this._convert.length === 1);\n        assert(this._makeNullValue.length === 0);\n    }\n\n    validate(raw, key = null) {\n        if (!this._validate(raw)) throw new ValidationError(raw, key);\n    }\n\n    convert(raw) {\n        return this._convert(raw);\n    }\n\n    makeNullValue() {\n        return this._makeNullValue(this._convert);\n    }\n}\n\nexport class HigherOrderDescriptorType extends DescriptorType {\n    constructor(name, convert, makeNullValue) {\n        super(name, convert, makeNullValue);\n    }\n\n    _checkArities() {\n        assert(this._validate.length === 1);\n        assert(this._convert.length === 2);\n        assert(this._makeNullValue.length === 1);\n    }\n\n    convert(factory, raw) {\n        assert(typeof factory === 'function');\n\n        return this._convert(factory, raw);\n    }\n\n    makeNullValue(factory) {\n        assert(typeof factory === 'function');\n\n        return this._makeNullValue(factory);\n    }\n}\n\nexport const AnyDescriptorType = new DescriptorType(\n    {\n        validate: (raw) => true,\n        convert: (raw) => raw,\n        makeNull: () => null\n    },\n    'AnyDescriptorType'\n);\nexport const StringDescriptorType = new DescriptorType(\n    {\n        validate: (raw) => typeof raw === 'string',\n        convert: (raw) => raw,\n        makeNull: () => ''\n    },\n    'StringDescriptorType'\n);\nexport const NumberDescriptorType = new DescriptorType(\n    {\n        validate: (raw) => typeof raw === 'number',\n        convert: (raw) => raw,\n        makeNull: () => 0\n    },\n    'NumberDescriptorType'\n);\nexport const BooleanDescriptorType = new DescriptorType(\n    {\n        validate: (raw) => typeof raw === 'boolean',\n        convert: (raw) => raw,\n        makeNull: () => false\n    },\n    'BooleanDescriptorType'\n);\nexport const DateDescriptorType = new DescriptorType(\n    {\n        validate: (raw) => raw instanceof Date || new Date(raw).toString() !== 'Invalid Date',\n        convert: (raw) => (raw instanceof Date ? raw : new Date(raw)),\n        makeNull: () => new Date('1970-01-01')\n    },\n    'DateDescriptorType'\n);\n\nexport const NestedDescriptorType = new HigherOrderDescriptorType(\n    {\n        validate: (raw) => true, // @TODO provide better validation for NestedDescriptorType\n        convert: (convertBoxed, raw) => convertBoxed(raw),\n        makeNull: (factory) => factory()\n    },\n    'NestedDescriptorType'\n);\nexport const ArrayDescriptorType = new HigherOrderDescriptorType(\n    {\n        validate: (raw) => raw instanceof Array,\n        convert: (convertBoxed, raw) => raw.map((x) => convertBoxed(x)),\n        makeNull: (factory) => []\n    },\n    'ArrayDescriptorType'\n);\n","import {\n    assert,\n    empty,\n    factory,\n    Blueprint,\n    Extractor,\n    DescriptorType,\n    NestedDescriptorType,\n    Modifier,\n    IllegalModifierError,\n    BlueprintSpecificationError,\n    HigherOrderDescriptorType\n} from './internal';\n\n/**\n * Each instance is a characterization of one property of the target object. Does not contain any logic about the actual\n * extraction and conversion of\n */\nexport class Descriptor {\n    type;\n    key;\n    nested;\n    defaultValue;\n    beforeMutator = (x) => x;\n    afterMutator = (x) => x;\n    omitWhenPredicate = (x) => false;\n    _modifiers = [];\n\n    constructor(type) {\n        this.type = type;\n\n        return new Proxy(this, {\n            get(target, prop, receiver) {\n                if (Reflect.has(target, prop)) return Reflect.get(target, prop, receiver);\n\n                target._addModifier(prop);\n                return receiver;\n            }\n        });\n    }\n\n    // SET\n    setKey(key) {\n        assert(typeof key === 'string', 'Key should be a string, but it is not.');\n\n        if (empty(this.key)) this.key = key;\n        return this;\n    }\n\n    // @TODO make everything factories - or blueprints!\n    trySetNested(value) {\n        const attempts = [\n            {\n                condition: (x) => x instanceof DescriptorProxy,\n                set: (proxy) => (this.nested = (raw) => new Extractor(proxy.eject()).extract(raw)) // not a 'true' factory -> does not produce null values!\n            },\n            {\n                condition: (x) => x instanceof Descriptor,\n                set: (descriptor) => (this.nested = (raw) => new Extractor(descriptor).extract(raw)) // not a 'true' factory -> does not produce null values!\n            },\n            {\n                condition: (x) => x instanceof Function,\n                set: (fn) => (this.nested = fn) // produces null values depending on what is given\n            },\n            {\n                condition: (x) => x instanceof Blueprint,\n                set: (blueprint) => (this.nested = (raw) => blueprint.make(raw)) // 'true' factory -> produces null values reliably\n            },\n            {\n                condition: (x) => typeof x === 'object',\n                set: (specification) => (this.nested = factory(specification)) // 'true' factory -> produces null values reliably\n            }\n        ];\n\n        return attempts.some((attempt) => {\n            if (attempt.condition(value)) {\n                attempt.set(value);\n                return true;\n            }\n\n            return false;\n        });\n    }\n\n    default(value) {\n        this.defaultValue = value;\n        return this;\n    }\n\n    before(mutator) {\n        assert(typeof mutator === 'function', 'Mutator should be a function, but it is not.');\n        this.beforeMutator = mutator;\n        return this;\n    }\n\n    after(mutator) {\n        assert(typeof mutator === 'function', 'Mutator should be a function, but it is not.');\n        this.afterMutator = mutator;\n        return this;\n    }\n\n    omitWhen(predicate) {\n        assert(typeof predicate === 'function', 'Predicate should be a function, but it is not.');\n        this.omitWhenPredicate = predicate;\n        return this;\n    }\n\n    _addModifier(modifier) {\n        assert(typeof modifier === 'string', 'Modifier is expected to be of type string.');\n\n        if (!Modifier.has(modifier)) throw new IllegalModifierError(modifier);\n\n        this._modifiers.push(modifier);\n    }\n\n    // INTERROGATE\n    get hasKey() {\n        return this.key !== undefined;\n    }\n\n    get hasDefault() {\n        return this.defaultValue !== undefined;\n    }\n\n    hasModifier(modifier) {\n        return this._modifiers.includes(modifier);\n    }\n\n    // CHECK\n    checkIsReady() {\n        this._checkType();\n\n        if (this.type instanceof HigherOrderDescriptorType) {\n            assert(!empty(this.nested), 'Descriptor has higher order type but is not nested.');\n            assert(typeof this.nested === 'function', 'Nested should be wrapped as a function.');\n        }\n    }\n\n    _checkType() {\n        assert(!empty(this.type), 'Descriptor type is not set.');\n        assert(this.type instanceof DescriptorType, 'The descriptor type is not valid.');\n    }\n\n    // FACTORY\n    static fromSpecification(specification) {\n        if (specification instanceof Descriptor) return specification;\n        if (specification instanceof DescriptorProxy) return specification.eject();\n\n        const descriptor = new Descriptor(NestedDescriptorType);\n\n        if (!descriptor.trySetNested(specification)) throw new BlueprintSpecificationError(typeof specification);\n\n        return descriptor;\n    }\n}\n\nexport class DescriptorProxy extends Function {\n    constructor(type) {\n        super();\n\n        this._type = type;\n\n        return new Proxy(this, {\n            get: (target, prop, receiver) => {\n                return target._get(target, prop, receiver);\n            },\n            apply: (target, thisArg, args) => {\n                return target._call(...args);\n            }\n        });\n    }\n\n    _get(target, prop, receiver) {\n        if (Reflect.has(target, prop)) return Reflect.get(target, prop, receiver);\n\n        if (Modifier.has(prop)) {\n            const descriptor = target.eject();\n            descriptor._addModifier(prop);\n\n            return descriptor;\n        }\n\n        if (['default', 'before', 'after'].includes(prop)) {\n            const descriptor = target.eject();\n\n            return (value) => {\n                descriptor[prop](value);\n                return descriptor;\n            };\n        }\n\n        if (typeof prop === 'string') throw new IllegalModifierError(prop);\n    }\n\n    _call(...args) {\n        const descriptor = this.eject();\n\n        if (args.length < 1) return descriptor;\n\n        if (descriptor.type instanceof HigherOrderDescriptorType) {\n            if (!descriptor.trySetNested(args.shift())) throw new BlueprintSpecificationError();\n        }\n\n        if (args.length < 1) return descriptor;\n        descriptor.setKey(args.shift());\n\n        return descriptor;\n    }\n\n    eject() {\n        return new Descriptor(this._type);\n    }\n}\n\nexport function CustomDescriptor(name, convert, makeNullValue) {\n    return new DescriptorProxy(new DescriptorType(name, convert, makeNullValue));\n}\n\nexport function CustomHigherOrderDescriptor(name, convert, makeNullValue) {\n    return new DescriptorProxy(new HigherOrderDescriptorType(name, convert, makeNullValue));\n}\n","import { empty, isPlainObject, Extractor, MissingKeyOrValue } from './internal';\n\nexport class Blueprint {\n    constructor(specification) {\n        this.specification = specification;\n    }\n\n    make(raw) {\n        if (isPlainObject(this.specification)) return this._makeCompound(raw);\n\n        return this._makeSimple(raw);\n    }\n\n    _makeSimple(raw) {\n        const makeNullObject = empty(raw);\n        const extractor = Extractor.fromSpecification(this.specification);\n        const value = makeNullObject ? extractor.makeNullValue() : extractor.extract(raw);\n        if (value === MissingKeyOrValue) return;\n        return value;\n    }\n\n    _makeCompound(raw) {\n        const makeNullObject = empty(raw);\n\n        const entries = Object.entries(this.specification)\n            .map(([key, specification]) => {\n                const extractor = Extractor.fromSpecification(specification, key);\n                return [key, makeNullObject ? extractor.makeNullValue() : extractor.extract(raw)];\n            })\n            .filter(([key, value]) => value !== MissingKeyOrValue);\n\n        return Object.fromEntries(entries);\n    }\n}\n\nexport const blueprint = (specification) => new Blueprint(specification);\nexport const factory = (specification) => (raw) => blueprint(specification).make(raw);\n","import {\n    Descriptor,\n    DescriptorProxy,\n    HigherOrderDescriptorType,\n    MissingKeyError,\n    MissingKeyOrValue,\n    Modifier\n} from './internal';\n\n/**\n * Knows how to use a descriptor to extract a value from a raw object.\n */\n// @TODO support .cast modifier\nexport class Extractor {\n    constructor(descriptor) {\n        this.descriptor = descriptor instanceof DescriptorProxy ? descriptor.eject() : descriptor;\n        return this;\n    }\n\n    /**\n     * Takes a raw value or object. Unpacks the value to be converted when a key is present. Runs the conversion.\n     */\n    extract(raw) {\n        this.descriptor.checkIsReady();\n\n        if (this.descriptor.hasKey && typeof raw === 'object' && !raw.hasOwnProperty(this.descriptor.key)) {\n            if (this.descriptor.hasDefault) return this.descriptor.defaultValue;\n            if (this.descriptor.hasModifier(Modifier.MAYBE)) return null;\n            if (this.descriptor.hasModifier(Modifier.OPTIONAL)) return MissingKeyOrValue;\n            throw new MissingKeyError(this.descriptor.key, raw);\n        }\n\n        return this.convert(this.descriptor.hasKey ? raw[this.descriptor.key] : raw);\n    }\n\n    /**\n     * Converts a value according to descriptor. Applies mutators when applicable.\n     */\n    convert(value) {\n        if (this.descriptor.omitWhenPredicate(value)) {\n            return MissingKeyOrValue;\n        }\n\n        if ([null, undefined].includes(value)) {\n            if (this.descriptor.hasModifier(Modifier.MAYBE)) return null;\n            if (this.descriptor.hasModifier(Modifier.OPTIONAL)) return MissingKeyOrValue;\n        }\n\n        const type = this.descriptor.type;\n\n        value = this.descriptor.beforeMutator(value);\n\n        type.validate(value);\n\n        let convert = type.convert.bind(type);\n\n        const result =\n            this.descriptor.type instanceof HigherOrderDescriptorType\n                ? convert(this.descriptor.nested, value)\n                : convert(value);\n\n        return this.descriptor.afterMutator(result);\n    }\n\n    makeNullValue() {\n        this.descriptor.checkIsReady();\n\n        if (this.descriptor.hasModifier(Modifier.MAYBE)) return null;\n        if (this.descriptor.hasModifier(Modifier.OPTIONAL)) return MissingKeyOrValue;\n\n        const value = (() => {\n            if (this.descriptor.hasDefault) return this.descriptor.defaultValue;\n\n            if (this.descriptor.type instanceof HigherOrderDescriptorType)\n                return this.descriptor.type.makeNullValue(this.descriptor.nested);\n            return this.descriptor.type.makeNullValue();\n        })();\n\n        return this.convert(value);\n    }\n\n    static fromSpecification(specification, key = null) {\n        const descriptor = Descriptor.fromSpecification(specification);\n        if (key) descriptor.setKey(key);\n        return new Extractor(descriptor);\n    }\n}\n","import {\n    Blueprint,\n    CustomDescriptor,\n    CustomHigherOrderDescriptor,\n    Descriptor,\n    DescriptorProxy,\n    Extractor,\n    Modifier,\n    blueprint,\n    factory,\n    MissingKeyError,\n    IllegalModifierError,\n    AnyDescriptorType,\n    StringDescriptorType,\n    NumberDescriptorType,\n    BooleanDescriptorType,\n    DateDescriptorType,\n    NestedDescriptorType,\n    ArrayDescriptorType\n} from './internal';\n\nconst $Any = new DescriptorProxy(AnyDescriptorType);\nconst $String = new DescriptorProxy(StringDescriptorType);\nconst $Number = new DescriptorProxy(NumberDescriptorType);\nconst $Boolean = new DescriptorProxy(BooleanDescriptorType);\nconst $Date = new DescriptorProxy(DateDescriptorType);\nconst $One = new DescriptorProxy(NestedDescriptorType);\nconst $Many = new DescriptorProxy(ArrayDescriptorType);\n\nexport {\n    Blueprint,\n    CustomDescriptor,\n    CustomHigherOrderDescriptor,\n    Descriptor,\n    DescriptorProxy,\n    Extractor,\n    Modifier,\n    blueprint,\n    factory,\n    MissingKeyError,\n    IllegalModifierError,\n    AnyDescriptorType,\n    StringDescriptorType,\n    NumberDescriptorType,\n    BooleanDescriptorType,\n    DateDescriptorType,\n    NestedDescriptorType,\n    ArrayDescriptorType,\n    $Any,\n    $String,\n    $Number,\n    $Boolean,\n    $Date,\n    $One,\n    $Many\n};\n"],"names":["empty","value","includes","Object","Array","constructor","entries","length","assert","condition","message","join","Error","Modifier","[object Object]","elements","this","Proxy","get","target","prop","receiver","Reflect","has","element","values","MAYBE","OPTIONAL","MissingKeyOrValue","Symbol","MissingKeyError","key","raw","super","JSON","stringify","name","IllegalModifierError","modifier","BlueprintSpecificationError","type","ValidationError","DescriptorType","callbacks","forEach","callbackName","hasOwnProperty","_validate","validate","_convert","convert","_makeNullValue","makeNull","_name","_checkArities","HigherOrderDescriptorType","makeNullValue","factory","AnyDescriptorType","StringDescriptorType","NumberDescriptorType","BooleanDescriptorType","DateDescriptorType","Date","toString","NestedDescriptorType","convertBoxed","ArrayDescriptorType","map","x","Descriptor","_addModifier","DescriptorProxy","set","proxy","nested","Extractor","eject","extract","descriptor","Function","fn","Blueprint","blueprint","make","specification","some","attempt","defaultValue","mutator","beforeMutator","afterMutator","predicate","omitWhenPredicate","_modifiers","push","hasKey","undefined","hasDefault","_checkType","trySetNested","_type","_get","apply","thisArg","args","_call","shift","setKey","prototype","call","getPrototypeOf","isPlainObject","_makeCompound","_makeSimple","makeNullObject","extractor","fromSpecification","filter","fromEntries","checkIsReady","hasModifier","bind","result","$Any","$String","$Number","$Boolean","$Date","$One","$Many"],"mappings":"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"}