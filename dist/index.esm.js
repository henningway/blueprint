const e=function(e){return!["number","boolean"].includes(typeof e)&&([Object,Array].includes((e||{}).constructor)&&!Object.entries(e||{}).length)},t=function(e,t=""){if(!e){if(t=["Assertion failed",t].join(": "),"undefined"!=typeof Error)throw new Error(t);throw t}},i=new class{constructor(e={}){return this.elements=e,new Proxy(this,{get:(e,t,i)=>Reflect.has(e,t)?Reflect.get(e,t,i):e.elements[t]})}has(e){return this.values.includes(e)}get values(){return Object.values(this.elements)}}({MAYBE:"maybe",OPTIONAL:"optional"}),r=Symbol("missing key or value"),n=class extends Error{constructor(e,t){super(`The key '${e}' is missing from the object to be converted: ${JSON.stringify(t,null,2)}.`),this.name="MissingKeyError"}},s=class extends Error{constructor(e=null){super(`'${e}' is not a valid modifier.`),this.name="IllegalModifierError"}},o=class extends Error{constructor(e){super(`Blueprint specification contains illegal element of type ${e}.`),this.name="BlueprintSpecificationError"}},c=class extends Error{constructor(e,t=null){super(["Property",t?" with key "+t:""," of type "+typeof e," is invalid."].join("")),this.name="ValidationError"}};class a{_validate;_convert;_makeNullValue;_name;constructor(e,i=""){["validate","convert","makeNull"].forEach((i=>{t(e.hasOwnProperty(i),`Cannot instantiate DescriptorType: missing callback '${i}'.`),t("function"==typeof e[i],`Cannot instantiate DescriptorType: '${i}' should be a function.`)})),this._validate=e.validate,this._convert=e.convert,this._makeNullValue=e.makeNull,this._name=i,this._checkArities()}_checkArities(){t(1===this._validate.length),t(1===this._convert.length),t(0===this._makeNullValue.length)}validate(e,t=null){if(!this._validate(e))throw new c(e,t)}convert(e){return this._convert(e)}makeNullValue(){return this._makeNullValue(this._convert)}}class l extends a{constructor(e,t,i){super(e,t,i)}_checkArities(){t(1===this._validate.length),t(2===this._convert.length),t(1===this._makeNullValue.length)}convert(e,i){return t("function"==typeof e),this._convert(e,i)}makeNullValue(e){return t("function"==typeof e),this._makeNullValue(e)}}const u=new a({validate:e=>!0,convert:e=>e,makeNull:()=>null},"AnyDescriptorType"),h=new a({validate:e=>"string"==typeof e,convert:e=>e,makeNull:()=>""},"StringDescriptorType"),f=new a({validate:e=>"number"==typeof e,convert:e=>e,makeNull:()=>0},"NumberDescriptorType"),d=new a({validate:e=>"boolean"==typeof e,convert:e=>e,makeNull:()=>!1},"BooleanDescriptorType"),p=new a({validate:e=>e instanceof Date||"Invalid Date"!==new Date(e).toString(),convert:e=>e instanceof Date?e:new Date(e),makeNull:()=>new Date("1970-01-01")},"DateDescriptorType"),y=new l({validate:e=>!0,convert:(e,t)=>e(t),makeNull:e=>e()},"NestedDescriptorType"),m=new l({validate:e=>e instanceof Array,convert:(e,t)=>t.map((t=>e(t))),makeNull:e=>[]},"ArrayDescriptorType");class v{type;key;nested;defaultValue;beforeMutator=e=>e;afterMutator=e=>e;omitWhenPredicate=e=>!1;_modifiers=[];constructor(e){return this.type=e,new Proxy(this,{get:(e,t,i)=>Reflect.has(e,t)?Reflect.get(e,t,i):(e._addModifier(t),i)})}setKey(i){return t("string"==typeof i,"Key should be a string, but it is not."),e(this.key)&&(this.key=i),this}trySetNested(e){return[{condition:e=>e instanceof w,set:e=>this.nested=t=>new M(e.eject()).extract(t)},{condition:e=>e instanceof v,set:e=>this.nested=t=>new M(e).extract(t)},{condition:e=>e instanceof Function,set:e=>this.nested=e},{condition:e=>e instanceof b,set:e=>this.nested=t=>e.make(t)},{condition:e=>"object"==typeof e,set:e=>this.nested=N(e)}].some((t=>!!t.condition(e)&&(t.set(e),!0)))}default(e){return this.defaultValue=e,this}before(e){return t("function"==typeof e,"Mutator should be a function, but it is not."),this.beforeMutator=e,this}after(e){return t("function"==typeof e,"Mutator should be a function, but it is not."),this.afterMutator=e,this}omitWhen(e){return t("function"==typeof e,"Predicate should be a function, but it is not."),this.omitWhenPredicate=e,this}_addModifier(e){if(t("string"==typeof e,"Modifier is expected to be of type string."),!i.has(e))throw new s(e);this._modifiers.push(e)}get hasKey(){return void 0!==this.key}get hasDefault(){return void 0!==this.defaultValue}hasModifier(e){return this._modifiers.includes(e)}checkIsReady(){this._checkType(),this.type instanceof l&&(t(!e(this.nested),"Descriptor has higher order type but is not nested."),t("function"==typeof this.nested,"Nested should be wrapped as a function."))}_checkType(){t(!e(this.type),"Descriptor type is not set."),t(this.type instanceof a,"The descriptor type is not valid.")}static fromSpecification(e){if(e instanceof v)return e;if(e instanceof w)return e.eject();const t=new v(y);if(!t.trySetNested(e))throw new o(typeof e);return t}}class w extends Function{constructor(e){return super(),this._type=e,new Proxy(this,{get:(e,t,i)=>e._get(e,t,i),apply:(e,t,i)=>e._call(...i)})}_get(e,t,r){if(Reflect.has(e,t))return Reflect.get(e,t,r);if(i.has(t)){const i=e.eject();return i._addModifier(t),i}if(["default","before","after"].includes(t)){const i=e.eject();return e=>(i[t](e),i)}if("string"==typeof t)throw new s(t)}_call(...e){const t=this.eject();if(e.length<1)return t;if(t.type instanceof l&&!t.trySetNested(e.shift()))throw new o;return e.length<1||t.setKey(e.shift()),t}eject(){return new v(this._type)}}function k(e,t,i){return new w(new a(e,t,i))}function _(e,t,i){return new w(new l(e,t,i))}class b{constructor(e){this.specification=e}make(e){return function(e){if("[object Object]"!==Object.prototype.toString.call(e))return!1;const t=Object.getPrototypeOf(e);return null===t||t===Object.prototype}(this.specification)?this._makeCompound(e):this._makeSimple(e)}_makeSimple(t){const i=e(t),n=M.fromSpecification(this.specification),s=i?n.makeNullValue():n.extract(t);if(s!==r)return s}_makeCompound(t){const i=e(t),n=Object.entries(this.specification).map((([e,r])=>{const n=M.fromSpecification(r,e);return[e,i?n.makeNullValue():n.extract(t)]})).filter((([e,t])=>t!==r));return Object.fromEntries(n)}}const g=e=>new b(e),N=e=>t=>g(e).make(t);class M{constructor(e){return this.descriptor=e instanceof w?e.eject():e,this}extract(e){if(this.descriptor.checkIsReady(),this.descriptor.hasKey&&"object"==typeof e&&!e.hasOwnProperty(this.descriptor.key)){if(this.descriptor.hasDefault)return this.descriptor.defaultValue;if(this.descriptor.hasModifier(i.MAYBE))return null;if(this.descriptor.hasModifier(i.OPTIONAL))return r;throw new n(this.descriptor.key,e)}return this.convert(this.descriptor.hasKey?e[this.descriptor.key]:e)}convert(e){if(this.descriptor.omitWhenPredicate(e))return r;if([null,void 0].includes(e)){if(this.descriptor.hasModifier(i.MAYBE))return null;if(this.descriptor.hasModifier(i.OPTIONAL))return r}const t=this.descriptor.type;e=this.descriptor.beforeMutator(e),t.validate(e);let n=t.convert.bind(t);const s=this.descriptor.type instanceof l?n(this.descriptor.nested,e):n(e);return this.descriptor.afterMutator(s)}makeNullValue(){if(this.descriptor.checkIsReady(),this.descriptor.hasModifier(i.MAYBE))return null;if(this.descriptor.hasModifier(i.OPTIONAL))return r;const e=(()=>this.descriptor.hasDefault?this.descriptor.defaultValue:this.descriptor.type instanceof l?this.descriptor.type.makeNullValue(this.descriptor.nested):this.descriptor.type.makeNullValue())();return this.convert(e)}static fromSpecification(e,t=null){const i=v.fromSpecification(e);return t&&i.setKey(t),new M(i)}}const j=new w(u),D=new w(h),O=new w(f),V=new w(d),T=new w(p),x=new w(y),A=new w(m);export{j as $Any,V as $Boolean,T as $Date,A as $Many,O as $Number,x as $One,D as $String,u as AnyDescriptorType,m as ArrayDescriptorType,b as Blueprint,d as BooleanDescriptorType,k as CustomDescriptor,_ as CustomHigherOrderDescriptor,p as DateDescriptorType,v as Descriptor,w as DescriptorProxy,M as Extractor,s as IllegalModifierError,n as MissingKeyError,i as Modifier,y as NestedDescriptorType,f as NumberDescriptorType,h as StringDescriptorType,g as blueprint,N as factory};
//# sourceMappingURL=index.esm.js.map
