!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).Blueprint={})}(this,(function(e){"use strict";const t=function(e){return!["number","boolean"].includes(typeof e)&&([Object,Array].includes((e||{}).constructor)&&!Object.entries(e||{}).length)},s=function(e,t=""){if(!e){if(t=["Assertion failed",t].join(": "),"undefined"!=typeof Error)throw new Error(t);throw t}},r=class{constructor(e={}){return this.elements=e,new Proxy(this,{get:(e,t,s)=>Reflect.has(e,t)?Reflect.get(e,t,s):e.elements[t]})}has(e){return this.values.includes(e)}get values(){return Object.values(this.elements)}},i=new r({MAYBE:"maybe",OPTIONAL:"optional"}),n=new r({ANY:"ANY",STRING:"STRING",NUMBER:"NUMBER",BOOLEAN:"BOOLEAN",DATE:"DATE",NESTED:"NESTED",ARRAY:"ARRAY"}),o=new r({PASS_THROUGH:"PASS_THROUGH",PRIMITIVE:"PRIMITIVE",DESCRIPTOR:"DESCRIPTOR",FACTORY:"FACTORY"}),c=Symbol("missing key or value"),a=class extends Error{constructor(e){super(`The key '${e}' is missing from the object to be converted.`),this.name="MissingKeyError"}},h=class extends Error{constructor(e=null){super(`'${e}' is not a valid modifier.`),this.name="IllegalModifierError"}},u=class extends Error{constructor(e){super(`Blueprint specification contains illegal element of type ${e}.`),this.name="BlueprintSpecificationError"}};class l extends Function{constructor(e,t,s=!1){switch(super(),this.type=e,this.defaultValue=t,this.ejected=s,this.key=null,this.caster=null,this.mutator=null,this.modifiers=[],e){case n.ANY:this.caster=e=>e;break;case n.STRING:this.caster=String;break;case n.NUMBER:this.caster=Number;break;case n.BOOLEAN:this.caster=Boolean;break;case n.DATE:this.caster=e=>e instanceof Date?e:new Date(e)}return new Proxy(this,{get:(e,t,s)=>{if(Reflect.has(e,t))return Reflect.get(e,t,s);if(i.has(t))return(e=e.eject()).addModifier(t),e;if("default"===t)return e=e.eject(),t=>(e.defaultValue=t,e);if("string"==typeof t)throw new h(t)},apply:(e,t,s)=>e.ejected?Reflect.apply(e,t,s):(e=e.eject()).call(...s)})}call(...e){if(e.length>0)if(e[0]instanceof l)this.setCaster(e.shift());else if(e[0]instanceof Function)this.setCaster(e.shift());else if(e[0]instanceof f){const t=e.shift();this.setCaster((e=>t.make(e)))}else"object"==typeof e[0]&&this.setCaster(p(e.shift()));return e.length>0&&this.setKey(e.shift()),e.length>0&&this.setMutator(e.shift()),this}setCaster(e){return this.caster=e,this.checkCaster(),this}setKey(e){return s("string"==typeof e,"Key should be a string, but it is not."),t(this.key)&&(this.key=e),this}setMutator(e){return s("function"==typeof e,"Mutator should be a function, but it is not."),this.mutator=e,this}addModifier(e){this.modifiers.push(e)}checkType(){s(!t(this.type),"Descriptor type is not set."),s(n.has(this.type),"The descriptor type is not valid.")}checkCaster(){s(!t(this.caster),"Caster is not set."),s(o.has(this.casterType),"The caster is not valid.")}get hasKey(){return null!==this.key}hasModifier(e){return this.modifiers.includes(e)}get casterType(){if([String,Number,Boolean,Date].includes(this.caster))return o.PRIMITIVE;if(this.caster instanceof l)return o.DESCRIPTOR;if(this.caster instanceof Function)return o.FACTORY;throw new Error("Caster is not set.")}get hasMutator(){return"function"==typeof this.mutator}checkIsReady(){s(this.ejected,"Descriptor has not been ejected."),this.checkType(),this.checkCaster()}get hasDefault(){return void 0!==this.defaultValue}eject(){return this.ejected?this:new l(this.type,this.defaultValue,!0)}}class f{constructor(e={}){this.specification=e}make(e={}){const s={},r=t(e);return Object.entries(this.specification).forEach((([t,i])=>{if(!(i instanceof l)){const e=typeof i;if(!(i instanceof f||"function"===e||"object"===e))throw new u(e);i=new l(n.NESTED)(i)}const o=new y(i.eject().setKey(t));if(r)return void(s[t]=o.makeNullValue());const a=o.extract(e);a!==c&&(s[t]=a)})),s}}const d=e=>new f(e),p=e=>t=>d(e).make(t);class y{constructor(e){return this.descriptor=e.eject(),this}extract(e){if(this.descriptor.checkIsReady(),this.descriptor.hasKey&&"object"==typeof e&&!e.hasOwnProperty(this.descriptor.key)){if(this.descriptor.hasDefault)return this.descriptor.defaultValue;if(this.descriptor.hasModifier(i.MAYBE))return null;if(this.descriptor.hasModifier(i.OPTIONAL))return c;throw new a(this.descriptor.key)}return this.convert(this.descriptor.hasKey?e[this.descriptor.key]:e)}convert(e){if([null,void 0].includes(e)){if(this.descriptor.hasModifier(i.MAYBE))return null;if(this.descriptor.hasModifier(i.OPTIONAL))return c}const t=this.applyMutator(this.caster);return this.descriptor.type===n.ARRAY?e.map((e=>t(e))):t(e)}get caster(){return this.descriptor.casterType===o.DESCRIPTOR?e=>new y(this.descriptor.caster).extract(e):this.descriptor.caster}applyMutator(e){return this.descriptor.hasMutator?t=>e(this.descriptor.mutator(t)):e}makeNullValue(){const e=(()=>{if(this.descriptor.hasDefault)return this.descriptor.defaultValue;switch(this.descriptor.type){case n.ARRAY:return[];case n.ANY:return null;case n.DATE:return new Date("1970-01-01");default:return""}})();return this.convert(e)}}const E=new l(n.ANY),R=new l(n.STRING),A=new l(n.NUMBER),T=new l(n.BOOLEAN),w=new l(n.DATE),m=new l(n.NESTED),b=new l(n.ARRAY);e.$Any=E,e.$Boolean=T,e.$Date=w,e.$Many=b,e.$Number=A,e.$One=m,e.$String=R,e.Blueprint=f,e.IllegalModifierError=h,e.MissingKeyError=a,e.blueprint=d,e.factory=p,Object.defineProperty(e,"__esModule",{value:!0})}));
