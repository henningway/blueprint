!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).Blueprint={})}(this,(function(e){"use strict";const t=function(e){return!["number","boolean"].includes(typeof e)&&([Object,Array].includes((e||{}).constructor)&&!Object.entries(e||{}).length)},r=function(e,t=""){if(!e){if(t=["Assertion failed",t].join(": "),"undefined"!=typeof Error)throw new Error(t);throw t}},i=new class{constructor(e={}){return this.elements=e,new Proxy(this,{get:(e,t,r)=>Reflect.has(e,t)?Reflect.get(e,t,r):e.elements[t]})}has(e){return this.values.includes(e)}get values(){return Object.values(this.elements)}}({MAYBE:"maybe",OPTIONAL:"optional"}),s=Symbol("missing key or value"),n=class extends Error{constructor(e,t){super(`The key '${e}' is missing from the object to be converted: ${JSON.stringify(t,null,2)}.`),this.name="MissingKeyError"}},o=class extends Error{constructor(e=null){super(`'${e}' is not a valid modifier.`),this.name="IllegalModifierError"}},c=class extends Error{constructor(e){super(`Blueprint specification contains illegal element of type ${e}.`),this.name="BlueprintSpecificationError"}},a=class extends Error{constructor(e,t=null){super(["Property",t?" with key "+t:""," of type "+typeof e," is invalid."].join("")),this.name="ValidationError"}};class u{_validate;_convert;_makeNullValue;_name;constructor(e,t,i,s=""){r("function"==typeof e,"Parameter 'convert' should be a function."),r("function"==typeof t,"Parameter 'convert' should be a function."),r("function"==typeof i,"Parameter 'makeNullValue' should be a function."),this._validate=e,this._convert=t,this._makeNullValue=i,this._name=s,this._checkArities()}_checkArities(){r(1===this._validate.length),r(1===this._convert.length),r(0===this._makeNullValue.length)}validate(e,t=null){if(!this._validate(e))throw new a(e,t)}convert(e){return this._convert(e)}makeNullValue(){return this._makeNullValue(this._convert)}}class l extends u{constructor(e,t,r){super(e,t,r)}_checkArities(){r(1===this._validate.length),r(2===this._convert.length),r(1===this._makeNullValue.length)}convert(e,t){return r("function"==typeof e),this._convert(e,t)}makeNullValue(e){return r("function"==typeof e),this._makeNullValue(e)}}const f=new u((e=>!0),(e=>e),(()=>null),"AnyDescriptorType"),h=new u((e=>"string"==typeof e),(e=>e),(()=>""),"StringDescriptorType"),p=new u((e=>"number"==typeof e),(e=>e),(()=>0),"NumberDescriptorType"),d=new u((e=>"boolean"==typeof e),(e=>e),(()=>!1),"BooleanDescriptorType"),y=new u((e=>e instanceof Date||"Invalid Date"!==new Date(e).toString()),(e=>e instanceof Date?e:new Date(e)),(()=>new Date("1970-01-01")),"DateDescriptorType"),m=new l((e=>!0),((e,t)=>e(t)),(e=>e()),"NestedDescriptorType"),w=new l((e=>e instanceof Array),((e,t)=>t.map((t=>e(t)))),(e=>[]),"ArrayDescriptorType");class g{type;key;nested;defaultValue;beforeMutator=e=>e;afterMutator=e=>e;_modifiers=[];constructor(e){return this.type=e,new Proxy(this,{get:(e,t,r)=>Reflect.has(e,t)?Reflect.get(e,t,r):(e._addModifier(t),r)})}setKey(e){return r("string"==typeof e,"Key should be a string, but it is not."),t(this.key)&&(this.key=e),this}trySetNested(e){return[{condition:e=>e instanceof b,set:e=>this.nested=t=>new D(e.eject()).extract(t)},{condition:e=>e instanceof g,set:e=>this.nested=t=>new D(e).extract(t)},{condition:e=>e instanceof Function,set:e=>this.nested=e},{condition:e=>e instanceof _,set:e=>this.nested=t=>e.make(t)},{condition:e=>"object"==typeof e,set:e=>this.nested=k(e)}].some((t=>!!t.condition(e)&&(t.set(e),!0)))}default(e){return this.defaultValue=e,this}before(e){return r("function"==typeof e,"Mutator should be a function, but it is not."),this.beforeMutator=e,this}after(e){return r("function"==typeof e,"Mutator should be a function, but it is not."),this.afterMutator=e,this}_addModifier(e){if(r("string"==typeof e,"Modifier is expected to be of type string."),!i.has(e))throw new o(e);this._modifiers.push(e)}get hasKey(){return void 0!==this.key}get hasDefault(){return void 0!==this.defaultValue}hasModifier(e){return this._modifiers.includes(e)}checkIsReady(){this._checkType(),this.type instanceof l&&(r(!t(this.nested),"Descriptor has higher order type but is not nested."),r("function"==typeof this.nested,"Nested should be wrapped as a function."))}_checkType(){r(!t(this.type),"Descriptor type is not set."),r(this.type instanceof u,"The descriptor type is not valid.")}static fromSpecificationValue(e){if(e instanceof g)return e;if(e instanceof b)return e.eject();const t=new g(m);if(!t.trySetNested(e))throw new c(typeof e);return t}}class b extends Function{_type;constructor(e){return super(),this._type=e,new Proxy(this,{get:(e,t,r)=>e._get(e,t,r),apply:(e,t,r)=>e._call(...r)})}_get(e,t,r){if(Reflect.has(e,t))return Reflect.get(e,t,r);if(i.has(t)){const r=e.eject();return r._addModifier(t),r}if(["default","before","after"].includes(t)){const r=e.eject();return e=>(r[t](e),r)}if("string"==typeof t)throw new o(t)}_call(...e){const t=this.eject();if(e.length<1)return t;if(t.type instanceof l&&!t.trySetNested(e.shift()))throw new c;return e.length<1||t.setKey(e.shift()),t}eject(){return new g(this._type)}}class _{constructor(e={}){this.specification=e}make(e={}){const r={},i=t(e);return Object.entries(this.specification).forEach((([t,n])=>{const o=D.fromSpecificationEntry(t,n),c=i?o.makeNullValue():o.extract(e);c!==s&&(r[t]=c)})),r}}const v=e=>new _(e),k=e=>t=>v(e).make(t);class D{constructor(e){return this.descriptor=e instanceof b?e.eject():e,this}extract(e){if(this.descriptor.checkIsReady(),this.descriptor.hasKey&&"object"==typeof e&&!e.hasOwnProperty(this.descriptor.key)){if(this.descriptor.hasDefault)return this.descriptor.defaultValue;if(this.descriptor.hasModifier(i.MAYBE))return null;if(this.descriptor.hasModifier(i.OPTIONAL))return s;throw new n(this.descriptor.key,e)}return this.convert(this.descriptor.hasKey?e[this.descriptor.key]:e)}convert(e){if([null,void 0].includes(e)){if(this.descriptor.hasModifier(i.MAYBE))return null;if(this.descriptor.hasModifier(i.OPTIONAL))return s}const t=this.descriptor.type;e=this.descriptor.beforeMutator(e),t.validate(e);let r=t.convert.bind(t);const n=this.descriptor.type instanceof l?r(this.descriptor.nested,e):r(e);return this.descriptor.afterMutator(n)}makeNullValue(){if(this.descriptor.checkIsReady(),this.descriptor.hasModifier(i.MAYBE))return null;if(this.descriptor.hasModifier(i.OPTIONAL))return s;const e=(()=>this.descriptor.hasDefault?this.descriptor.defaultValue:this.descriptor.type instanceof l?this.descriptor.type.makeNullValue(this.descriptor.nested):this.descriptor.type.makeNullValue())();return this.convert(e)}static fromSpecificationEntry(e,t){const r=g.fromSpecificationValue(t).setKey(e);return new D(r)}}const M=new b(f),N=new b(h),T=new b(p),V=new b(d),E=new b(y),x=new b(m),A=new b(w);e.$Any=M,e.$Boolean=V,e.$Date=E,e.$Many=A,e.$Number=T,e.$One=x,e.$String=N,e.AnyDescriptorType=f,e.ArrayDescriptorType=w,e.Blueprint=_,e.BooleanDescriptorType=d,e.CustomDescriptor=function(e,t,r){return new b(new u(e,t,r))},e.CustomHigherOrderDescriptor=function(e,t,r){return new b(new l(e,t,r))},e.DateDescriptorType=y,e.Descriptor=g,e.DescriptorProxy=b,e.Extractor=D,e.IllegalModifierError=o,e.MissingKeyError=n,e.Modifier=i,e.NestedDescriptorType=m,e.NumberDescriptorType=p,e.StringDescriptorType=h,e.blueprint=v,e.factory=k,Object.defineProperty(e,"__esModule",{value:!0})}));
