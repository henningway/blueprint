!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Blueprint={})}(this,(function(t){"use strict";const e=function(t){return!["number","boolean"].includes(typeof t)&&([Object,Array].includes((t||{}).constructor)&&!Object.entries(t||{}).length)},r=function(t,e=""){if(!t){if(e=["Assertion failed",e].join(": "),"undefined"!=typeof Error)throw new Error(e);throw e}},s=class{constructor(t={}){return this.elements=t,new Proxy(this,{get:(t,e,r)=>Reflect.has(t,e)?Reflect.get(t,e,r):t.elements[e]})}has(t){return this.values.includes(t)}get values(){return Object.values(this.elements)}},i=class extends Error{constructor(t){super(`The key '${t}' is missing from the object to be converted.`),this.name="MissingKeyError"}},n=class extends Error{constructor(t=null){super(`'${t}' is not a valid modifier.`),this.name="IllegalModifierError"}},o=Symbol("missing key or value"),c=new s({MAYBE:"maybe",OPTIONAL:"optional"}),a=new s({DESCRIPTOR:"descriptor",FACTORY:"factory",PRIMITIVE:"primitive"});class h{constructor(t={}){this.specification=t}make(t={}){const r={},s=e(t);return Object.entries(this.specification).forEach((([e,i])=>{(i=i.eject()).setKey(e);const n=new u(i);if(s)return void(r[e]=n.makeNullValue());n.extract(t)!==o&&(r[e]=n.extract(t))})),r}}class u{constructor(t){return this.descriptor=t.eject(),this}extract(t){if(this.descriptor.checkIsReady(),"object"==typeof t&&!t.hasOwnProperty(this.descriptor.key)){if(this.descriptor.hasModifier(c.MAYBE))return null;if(this.descriptor.hasModifier(c.OPTIONAL))return o;throw new i(this.descriptor.key)}return this.convert(this.descriptor.hasKey?t[this.descriptor.key]:t)}convert(t){if([null,void 0].includes(t)){if(this.descriptor.hasModifier(c.MAYBE))return null;if(this.descriptor.hasModifier(c.OPTIONAL))return o}const e=this.applyMutator(this.caster);return this.descriptor.casterType===a.DESCRIPTOR||this.descriptor.casterType===a.FACTORY?t.map((t=>e(t))):e(t)}get caster(){return this.descriptor.casterType===a.DESCRIPTOR?t=>new u(this.descriptor.caster).extract(t):this.descriptor.caster}applyMutator(t){return this.descriptor.hasMutator?e=>t(this.descriptor.mutator(e)):t}makeNullValue(){return this.convert(this.descriptor.casterType===a.DESCRIPTOR?[]:"")}}class l extends Function{constructor(t=null,e=!1){return super(),this.caster=t,this.key=null,this.mutator=null,this.ejected=e,this.modifiers=[],new Proxy(this,{get:(t,e,r)=>{if(Reflect.has(t,e))return Reflect.get(t,e,r);if(c.has(e))return(t=t.eject()).addModifier(e),t;if("string"==typeof e)throw new n(e)},apply:(t,e,r)=>(t=t.eject()).call(...r)})}call(...t){return t.length>0&&(t[0]instanceof l||t[0]instanceof Function)&&this.setCaster(t.shift()),t.length>0&&this.setKey(t.shift()),t.length>0&&this.setMutator(t.shift()),this}setCaster(t){return this.caster=t,this.checkCaster(),this}setKey(t){return r("string"==typeof t,"Key should be a string, but it is not."),e(this.key)&&(this.key=t),this}setMutator(t){return r("function"==typeof t,"Mutator should be a function, but it is not."),this.mutator=t,this}addModifier(t){this.modifiers.push(t)}checkCaster(){r(!e(this.caster),"Descriptor caster is not set."),r(null!==this.casterType,"The caster of the descriptor is not valid.")}get hasKey(){return null!==this.key}hasModifier(t){return this.modifiers.includes(t)}get casterType(){return[String,Boolean,Number].includes(this.caster)?a.PRIMITIVE:this.caster instanceof l?a.DESCRIPTOR:this.caster instanceof Function?a.FACTORY:null}get hasMutator(){return"function"==typeof this.mutator}checkIsReady(){r(this.ejected,"Descriptor has not been ejected."),this.checkCaster()}eject(){return this.ejected?this:new l(this.caster,!0)}}const d=new l(String),f=new l(Number),p=new l(Boolean),y=new l,m=t=>new h(t);t.$Boolean=p,t.$Many=y,t.$Number=f,t.$String=d,t.Blueprint=h,t.IllegalModifierError=n,t.MissingKeyError=i,t.blueprint=m,t.factory=t=>e=>m(t).make(e),Object.defineProperty(t,"__esModule",{value:!0})}));
