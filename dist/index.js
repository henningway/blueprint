!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Blueprint={})}(this,(function(t){"use strict";const e=function(t){return!["number","boolean"].includes(typeof t)&&([Object,Array].includes((t||{}).constructor)&&!Object.entries(t||{}).length)},s=function(t,e=""){if(!t){if(e=["Assertion failed",e].join(": "),"undefined"!=typeof Error)throw new Error(e);throw e}},r=new class{constructor(t={}){return this.elements=t,new Proxy(this,{get:(t,e,s)=>Reflect.has(t,e)?Reflect.get(t,e,s):t.elements[e]})}has(t){return this.values.includes(t)}get values(){return Object.values(this.elements)}}({MAYBE:"maybe",OPTIONAL:"optional"}),i=Symbol("missing key or value"),n=class extends Error{constructor(t,e){super(`The key '${t}' is missing from the object to be converted: ${JSON.stringify(e,null,2)}.`),this.name="MissingKeyError"}},o=class extends Error{constructor(t=null){super(`'${t}' is not a valid modifier.`),this.name="IllegalModifierError"}},c=class extends Error{constructor(t){super(`Blueprint specification contains illegal element of type ${t}.`),this.name="BlueprintSpecificationError"}};class a{constructor(t,e){this._caster=t,this._makeNullValue=e}get caster(){return this._caster}get makeNullValue(){return this._makeNullValue}}class u extends a{constructor(t,e){super(t,e)}}const h=new a((t=>t),(t=>null)),l=new a((t=>String(t)),(t=>"")),d=new a((t=>Number(t)),(t=>0)),f=new a((t=>Boolean(t)),(t=>!1)),p=new a((t=>t instanceof Date?t:new Date(t)),(t=>t("1970-01-01"))),y=new u(((t,e)=>e(t)),((t,e)=>t({},e))),m=new u(((t,e)=>t.map(e)),((t,e)=>[]));class w{type;key;nested;defaultValue;_modifiers=[];constructor(t){this.type=t}setKey(t){return s("string"==typeof t,"Key should be a string, but it is not."),e(this.key)&&(this.key=t),this}trySetNested(t){return[{condition:t=>t instanceof g,set:t=>this.nested=e=>new M(t.eject()).extract(e)},{condition:t=>t instanceof w,set:t=>this.nested=e=>new M(t).extract(e)},{condition:t=>t instanceof Function,set:t=>this.nested=t},{condition:t=>t instanceof _,set:t=>this.nested=e=>t.make(e)},{condition:t=>"object"==typeof t,set:t=>this.nested=k(t)}].some(((e,s)=>!!e.condition(t)&&(e.set(t),!0)))}setDefault(t){return this.defaultValue=t,this}setMutator(t){s("function"==typeof t,"Mutator should be a function, but it is not."),this.mutator=t}_addModifier(t){this._modifiers.push(t)}get hasKey(){return null!==this.key}get hasDefault(){return void 0!==this.defaultValue}get hasMutator(){return"function"==typeof this.mutator}hasModifier(t){return this._modifiers.includes(t)}checkIsReady(){this._checkType(),this.type instanceof u&&(s(!e(this.nested),"Descriptor has higher order type but is not nested."),s("function"==typeof this.nested,"Nested should be wrapped as a function."))}_checkType(){s(!e(this.type),"Descriptor type is not set."),s(this.type instanceof a,"The descriptor type is not valid.")}static fromSpecificationValue(t){if(t instanceof w)return t;if(t instanceof g)return t.eject();const e=new w(y);if(!e.trySetNested(t))throw new c(typeof t);return e}}class g extends Function{_descriptor;constructor(t){return super(),this._descriptor=new w(t),new Proxy(this,{get:(t,e,s)=>t._get(t,e,s),apply:(t,e,s)=>t._call(...s)})}_get(t,e,s){if(Reflect.has(t,e))return Reflect.get(t,e,s);if(r.has(e))return this._descriptor=t.eject(),this._descriptor._addModifier(e),this;if("default"===e)return this._descriptor=t.eject(),t=>(this._descriptor.setDefault(t),this);if("string"==typeof e)throw new o(e)}_call(...t){return t.length>0&&this._descriptor.trySetNested(t[0])&&t.shift(),t.length>0&&this._descriptor.setKey(t.shift()),t.length>0&&this._descriptor.setMutator(t.shift()),this}eject(){return this._descriptor}}class _{constructor(t={}){this.specification=t}make(t={}){const s={},r=e(t);return Object.entries(this.specification).forEach((([e,n])=>{const o=M.fromSpecificationEntry(e,n);if(r)return void(s[e]=o.makeNullValue());const c=o.extract(t);c!==i&&(s[e]=c)})),s}}const b=t=>new _(t),k=t=>e=>b(t).make(e);class M{constructor(t){return this.descriptor=t instanceof g?t.eject():t,this}extract(t){if(this.descriptor.checkIsReady(),this.descriptor.hasKey&&"object"==typeof t&&!t.hasOwnProperty(this.descriptor.key)){if(this.descriptor.hasDefault)return this.descriptor.defaultValue;if(this.descriptor.hasModifier(r.MAYBE))return null;if(this.descriptor.hasModifier(r.OPTIONAL))return i;throw new n(this.descriptor.key,t)}return this.convert(this.descriptor.hasKey?t[this.descriptor.key]:t)}convert(t){if([null,void 0].includes(t)){if(this.descriptor.hasModifier(r.MAYBE))return null;if(this.descriptor.hasModifier(r.OPTIONAL))return i}const e=this.applyMutator(this.descriptor.type.caster);return this.descriptor.type instanceof u?e(t,this.descriptor.nested):e(t)}applyMutator(t){return this.descriptor.hasMutator?(e,s)=>t(this.descriptor.mutator(e),s):t}makeNullValue(){this.descriptor.checkIsReady();const t=(()=>this.descriptor.hasDefault?this.descriptor.defaultValue:(this.descriptor.type instanceof u&&this.descriptor.type.makeNullValue(this.descriptor.type.caster,this.descriptor.nested),this.descriptor.type.makeNullValue(this.descriptor.type.caster)))();return this.convert(t)}static fromSpecificationEntry(t,e){const s=w.fromSpecificationValue(e).setKey(t);return new M(s)}}const N=new g(h),j=new g(l),E=new g(d),v=new g(f),x=new g(p),O=new g(y),V=new g(m);t.$Any=N,t.$Boolean=v,t.$Date=x,t.$Many=V,t.$Number=E,t.$One=O,t.$String=j,t.Blueprint=_,t.IllegalModifierError=o,t.MissingKeyError=n,t.blueprint=b,t.factory=k,Object.defineProperty(t,"__esModule",{value:!0})}));
